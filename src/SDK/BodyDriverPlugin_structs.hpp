#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BodyDriverPlugin

#include "Basic.hpp"

#include "AnimGraphRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum BodyDriverPlugin.BodyDriverMessageType
// NumValues: 0x001D
enum class EBodyDriverMessageType : uint8
{
	kMessageImpulseTypeDefault               = 0,
	kMessageImpulseTypeMelee                 = 1,
	kMessageImpulseTypeBullet                = 2,
	kMessageTriggerRagdollActivation         = 3,
	kMessageFreezeRagdollAndDisableCollision = 4,
	kMessageCharacterCollision               = 5,
	kMessageExplosion_Contact                = 6,
	kMessageExplosion_FreeOrigin             = 7,
	kMessageExplosion_MeleeUnstructuredFall  = 8,
	kMessageExplosion_BulletUnstructuredFall = 9,
	kMessageInitializeData                   = 10,
	kMessageFinalizeBodyDriver               = 11,
	kMessageForceSwitchToAnimated            = 12,
	kMessageShake                            = 13,
	kMessageShakeExplosion                   = 14,
	kMessage_END_LaunchSmallClose            = 15,
	kMessage_END_LaunchSmallFar              = 16,
	kMessage_END_BlowSmallClose              = 17,
	kMessage_END_BlowSmallFar                = 18,
	kMessage_END_LaunchLargeClose            = 19,
	kMessage_END_LaunchLargeFar              = 20,
	kMessage_END_BlowLargeClose              = 21,
	kMessage_END_BlowLargeFar                = 22,
	kMessage_END_Strike                      = 23,
	kMessageFallFromBike_END                 = 24,
	kMessage_END_Launch_Stagger              = 25,
	kMessage_END_Blow_Stagger                = 26,
	kMessage_END_Strike_Stagger              = 27,
	BodyDriverMessageType_MAX                = 28,
};

// Enum BodyDriverPlugin.eBodyParts
// NumValues: 0x006F
enum class EeBodyParts : uint8
{
	kPartPelvis                              = 0,
	kPartSpineBase                           = 1,
	kPartSpine1                              = 2,
	kPartSpine2                              = 3,
	kPartSpine3                              = 4,
	kPartSpine4                              = 5,
	kPartSpine5                              = 6,
	kPartSpine6                              = 7,
	kPartNeckBase                            = 8,
	kPartNeck1                               = 9,
	kPartNeck2                               = 10,
	kPartNeck3                               = 11,
	kPartNeck4                               = 12,
	kPartNeck5                               = 13,
	kPartNeck6                               = 14,
	kPartNeck7                               = 15,
	kPartNeck8                               = 16,
	kPartNeck9                               = 17,
	kPartNeck10                              = 18,
	kPartNeck11                              = 19,
	kPartNeck12                              = 20,
	kPartLeftArmBase                         = 21,
	kPartLeftArm1                            = 22,
	kPartLeftArm2                            = 23,
	kPartLeftArm3                            = 24,
	kPartLeftArm4                            = 25,
	kPartLeftArm5                            = 26,
	kPartLeftArm6                            = 27,
	kPartRightArmBase                        = 28,
	kPartRightArm1                           = 29,
	kPartRightArm2                           = 30,
	kPartRightArm3                           = 31,
	kPartRightArm4                           = 32,
	kPartRightArm5                           = 33,
	kPartRightArm6                           = 34,
	kPartLeftLegBase                         = 35,
	kPartLeftLeg1                            = 36,
	kPartLeftLeg2                            = 37,
	kPartLeftLeg3                            = 38,
	kPartLeftLeg4                            = 39,
	kPartLeftLeg5                            = 40,
	kPartLeftLeg6                            = 41,
	kPartRightLegBase                        = 42,
	kPartRightLeg1                           = 43,
	kPartRightLeg2                           = 44,
	kPartRightLeg3                           = 45,
	kPartRightLeg4                           = 46,
	kPartRightLeg5                           = 47,
	kPartRightLeg6                           = 48,
	kPartExtraLegABase                       = 49,
	kPartExtraLegA1                          = 50,
	kPartExtraLegA2                          = 51,
	kPartExtraLegA3                          = 52,
	kPartExtraLegA4                          = 53,
	kPartExtraLegA5                          = 54,
	kPartExtraLegA6                          = 55,
	kPartExtraLegBBase                       = 56,
	kPartExtraLegB1                          = 57,
	kPartExtraLegB2                          = 58,
	kPartExtraLegB3                          = 59,
	kPartExtraLegB4                          = 60,
	kPartExtraLegB5                          = 61,
	kPartExtraLegB6                          = 62,
	kAppendage1                              = 63,
	kAppendage2                              = 64,
	kAppendage3                              = 65,
	kAppendage4                              = 66,
	kAppendage5                              = 67,
	kAppendage6                              = 68,
	kAppendage7                              = 69,
	kAppendage8                              = 70,
	kAppendage9                              = 71,
	kAppendage10                             = 72,
	kAppendage11                             = 73,
	kAppendage12                             = 74,
	kAppendage13                             = 75,
	kAppendage14                             = 76,
	kAppendage15                             = 77,
	kAppendage16                             = 78,
	kAppendage17                             = 79,
	kAppendage18                             = 80,
	kAppendage19                             = 81,
	kAppendage20                             = 82,
	kAppendage21                             = 83,
	kAppendage22                             = 84,
	kAppendage23                             = 85,
	kAppendage24                             = 86,
	kAppendage25                             = 87,
	kAppendage26                             = 88,
	kAppendage27                             = 89,
	kAppendage28                             = 90,
	kAppendage29                             = 91,
	kAppendage30                             = 92,
	kAppendage31                             = 93,
	kAppendage32                             = 94,
	kAppendage33                             = 95,
	kAppendage34                             = 96,
	kAppendage35                             = 97,
	kAppendage36                             = 98,
	kAppendage37                             = 99,
	kAppendage38                             = 100,
	kAppendage39                             = 101,
	kAppendage40                             = 102,
	kAppendage41                             = 103,
	kAppendage42                             = 104,
	kAppendage43                             = 105,
	kAppendage44                             = 106,
	kAppendage45                             = 107,
	kInvalidPart                             = 108,
	kNumPossibleParts                        = 109,
	eBodyParts_MAX                           = 110,
};

// Enum BodyDriverPlugin.eEndBattleDamageSourceProperty_BD
// NumValues: 0x0005
enum class EeEndBattleDamageSourceProperty_BD : uint8
{
	PhysicsNear_BD                           = 0,
	Magic_BD                                 = 1,
	PhysicsFar_BD                            = 2,
	NotImportant_BD                          = 3,
	eEndBattleDamageSourceProperty_BD_MAX    = 4,
};

// Enum BodyDriverPlugin.eEndBattleDamageSourceHitReactionType_BD
// NumValues: 0x0019
enum class EeEndBattleDamageSourceHitReactionType_BD : uint8
{
	None_BD                                  = 2,
	Small_BD                                 = 0,
	Medium_BD                                = 8,
	Large_BD                                 = 1,
	LaunchSmall_BD                           = 3,
	LaunchLarge_BD                           = 9,
	BlowSmall_BD                             = 4,
	BlowLarge_BD                             = 10,
	Strike_BD                                = 5,
	SyncAction_BD                            = 6,
	Motion_BD                                = 7,
	Add_BD                                   = 11,
	Repel_BD                                 = 12,
	AerialDeadLaunchLarge_BD                 = 13,
	AerialDeadBlowLarge_BD                   = 14,
	AerialDeadStrike_BD                      = 15,
	AerialSuspendActionLaunchLarge_BD        = 16,
	BurstPushBlowLarge_BD                    = 17,
	FallDown_BD                              = 18,
	MotionBeginLoopEnd_BD                    = 19,
	MotionBeginLoopEndDamageHitProcessTimeLoopEnd_BD = 23,
	DownHit_BD                               = 20,
	PullBlow_BD                              = 21,
	PullMedium_BD                            = 22,
	eEndBattleDamageSourceHitReactionType_BD_MAX = 24,
};

// Enum BodyDriverPlugin.eCharacterType
// NumValues: 0x0006
enum class EeCharacterType : uint8
{
	kBiped                                   = 0,
	kQuadruped                               = 1,
	kSnake                                   = 2,
	kUnstructured                            = 3,
	kUnset                                   = 4,
	eCharacterType_MAX                       = 5,
};

// ScriptStruct BodyDriverPlugin.AnimNode_BodyDriver
// 0x0988 (0x0A50 - 0x00C8)
struct alignas(0x10) FAnimNode_BodyDriver : public FAnimNode_SkeletalControlBase
{
public:
	class UBodyDriver_BaseDataTuningSet*          BaseData;                                          // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedFallTuningSet*         BipedFall;                                         // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      BalanceRecovery;                                   // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      Staggerfall;                                       // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_ShakeTuningSet*             ShakeData;                                         // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      KnockbackBalance;                                  // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_FullBodyBipedIKTuningSet*   BipedIK;                                           // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_DebugImpulseTuningSet*      DebugImpulses;                                     // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAnim;                                          // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_ArchtypeTuningSet*          ArchtypeData;                                      // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ArchtypeSkeletalMesh;                              // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BaseDataTuningSet*          ArchtypeBaseData;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedFallTuningSet*         ArchtypeBipedFall;                                 // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      ArchtypeBalanceRecovery;                           // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      ArchtypeStaggerfall;                               // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_ShakeTuningSet*             ArchtypeShakeData;                                 // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_DebugImpulseTuningSet*      ArchtypeDebugImpulses;                             // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ArchtypeIdleAnim;                                  // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x1F0];                                    // 0x0158(0x01F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputObject_BodyDriver*                m_InputObject;                                     // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x700];                                    // 0x0350(0x0700)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BodyDriver) == 0x000010, "Wrong alignment on FAnimNode_BodyDriver");
static_assert(sizeof(FAnimNode_BodyDriver) == 0x000A50, "Wrong size on FAnimNode_BodyDriver");
static_assert(offsetof(FAnimNode_BodyDriver, BaseData) == 0x0000C8, "Member 'FAnimNode_BodyDriver::BaseData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, BipedFall) == 0x0000D0, "Member 'FAnimNode_BodyDriver::BipedFall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, BalanceRecovery) == 0x0000D8, "Member 'FAnimNode_BodyDriver::BalanceRecovery' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, Staggerfall) == 0x0000E0, "Member 'FAnimNode_BodyDriver::Staggerfall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ShakeData) == 0x0000E8, "Member 'FAnimNode_BodyDriver::ShakeData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, KnockbackBalance) == 0x0000F0, "Member 'FAnimNode_BodyDriver::KnockbackBalance' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, BipedIK) == 0x0000F8, "Member 'FAnimNode_BodyDriver::BipedIK' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, DebugImpulses) == 0x000100, "Member 'FAnimNode_BodyDriver::DebugImpulses' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, IdleAnim) == 0x000108, "Member 'FAnimNode_BodyDriver::IdleAnim' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeData) == 0x000110, "Member 'FAnimNode_BodyDriver::ArchtypeData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeSkeletalMesh) == 0x000118, "Member 'FAnimNode_BodyDriver::ArchtypeSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeBaseData) == 0x000120, "Member 'FAnimNode_BodyDriver::ArchtypeBaseData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeBipedFall) == 0x000128, "Member 'FAnimNode_BodyDriver::ArchtypeBipedFall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeBalanceRecovery) == 0x000130, "Member 'FAnimNode_BodyDriver::ArchtypeBalanceRecovery' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeStaggerfall) == 0x000138, "Member 'FAnimNode_BodyDriver::ArchtypeStaggerfall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeShakeData) == 0x000140, "Member 'FAnimNode_BodyDriver::ArchtypeShakeData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeDebugImpulses) == 0x000148, "Member 'FAnimNode_BodyDriver::ArchtypeDebugImpulses' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeIdleAnim) == 0x000150, "Member 'FAnimNode_BodyDriver::ArchtypeIdleAnim' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, m_InputObject) == 0x000348, "Member 'FAnimNode_BodyDriver::m_InputObject' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.ExtraSupportLimbPair
// 0x0050 (0x0050 - 0x0000)
struct FExtraSupportLimbPair final
{
public:
	class FString                                 Effector1BoneName;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Effector1LocalPointingDir;                         // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Effector1LocalUpDir;                               // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Effector2BoneName;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Effector2LocalPointingDir;                         // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Effector2LocalUpDir;                               // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtraSupportLimbPair) == 0x000008, "Wrong alignment on FExtraSupportLimbPair");
static_assert(sizeof(FExtraSupportLimbPair) == 0x000050, "Wrong size on FExtraSupportLimbPair");
static_assert(offsetof(FExtraSupportLimbPair, Effector1BoneName) == 0x000000, "Member 'FExtraSupportLimbPair::Effector1BoneName' has a wrong offset!");
static_assert(offsetof(FExtraSupportLimbPair, Effector1LocalPointingDir) == 0x000010, "Member 'FExtraSupportLimbPair::Effector1LocalPointingDir' has a wrong offset!");
static_assert(offsetof(FExtraSupportLimbPair, Effector1LocalUpDir) == 0x00001C, "Member 'FExtraSupportLimbPair::Effector1LocalUpDir' has a wrong offset!");
static_assert(offsetof(FExtraSupportLimbPair, Effector2BoneName) == 0x000028, "Member 'FExtraSupportLimbPair::Effector2BoneName' has a wrong offset!");
static_assert(offsetof(FExtraSupportLimbPair, Effector2LocalPointingDir) == 0x000038, "Member 'FExtraSupportLimbPair::Effector2LocalPointingDir' has a wrong offset!");
static_assert(offsetof(FExtraSupportLimbPair, Effector2LocalUpDir) == 0x000044, "Member 'FExtraSupportLimbPair::Effector2LocalUpDir' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.PartImpulseOverride
// 0x0008 (0x0008 - 0x0000)
struct FPartImpulseOverride final
{
public:
	EeBodyParts                                   Part;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Impulse;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartImpulseOverride) == 0x000004, "Wrong alignment on FPartImpulseOverride");
static_assert(sizeof(FPartImpulseOverride) == 0x000008, "Wrong size on FPartImpulseOverride");
static_assert(offsetof(FPartImpulseOverride, Part) == 0x000000, "Member 'FPartImpulseOverride::Part' has a wrong offset!");
static_assert(offsetof(FPartImpulseOverride, Impulse) == 0x000004, "Member 'FPartImpulseOverride::Impulse' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.GravityAndAirResistanceControl
// 0x0040 (0x0040 - 0x0000)
struct FGravityAndAirResistanceControl final
{
public:
	bool                                          EnableGravityControl;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityControlStartTime;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityControlRampUpTime;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityControlEndTime;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraGravityMultiplier;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAirResistanceControl;                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AirResistanceOnlyPlanar;                           // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AirResistanceControlStartTime;                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceControlRampUpTime;                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceControlEndTime;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceMaxSpeed;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceStrength;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleanupTime;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCollision;                                  // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableCollisionStartTime;                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableCollisionStopTime;                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGravityAndAirResistanceControl) == 0x000004, "Wrong alignment on FGravityAndAirResistanceControl");
static_assert(sizeof(FGravityAndAirResistanceControl) == 0x000040, "Wrong size on FGravityAndAirResistanceControl");
static_assert(offsetof(FGravityAndAirResistanceControl, EnableGravityControl) == 0x000000, "Member 'FGravityAndAirResistanceControl::EnableGravityControl' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, GravityControlStartTime) == 0x000004, "Member 'FGravityAndAirResistanceControl::GravityControlStartTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, GravityControlRampUpTime) == 0x000008, "Member 'FGravityAndAirResistanceControl::GravityControlRampUpTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, GravityControlEndTime) == 0x00000C, "Member 'FGravityAndAirResistanceControl::GravityControlEndTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, ExtraGravityMultiplier) == 0x000010, "Member 'FGravityAndAirResistanceControl::ExtraGravityMultiplier' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, EnableAirResistanceControl) == 0x000014, "Member 'FGravityAndAirResistanceControl::EnableAirResistanceControl' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceOnlyPlanar) == 0x000015, "Member 'FGravityAndAirResistanceControl::AirResistanceOnlyPlanar' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceControlStartTime) == 0x000018, "Member 'FGravityAndAirResistanceControl::AirResistanceControlStartTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceControlRampUpTime) == 0x00001C, "Member 'FGravityAndAirResistanceControl::AirResistanceControlRampUpTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceControlEndTime) == 0x000020, "Member 'FGravityAndAirResistanceControl::AirResistanceControlEndTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceMaxSpeed) == 0x000024, "Member 'FGravityAndAirResistanceControl::AirResistanceMaxSpeed' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceStrength) == 0x000028, "Member 'FGravityAndAirResistanceControl::AirResistanceStrength' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AngularDamping) == 0x00002C, "Member 'FGravityAndAirResistanceControl::AngularDamping' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, CleanupTime) == 0x000030, "Member 'FGravityAndAirResistanceControl::CleanupTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, DisableCollision) == 0x000034, "Member 'FGravityAndAirResistanceControl::DisableCollision' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, DisableCollisionStartTime) == 0x000038, "Member 'FGravityAndAirResistanceControl::DisableCollisionStartTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, DisableCollisionStopTime) == 0x00003C, "Member 'FGravityAndAirResistanceControl::DisableCollisionStopTime' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.Impulse
// 0x0198 (0x0198 - 0x0000)
struct FImpulse final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Impulse;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseArms;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseHands;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseLegs;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseMultWhenFallen;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseTime;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImpulseRelativeToPartMass;                         // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmountOfDecayPerStage;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumDecayStages;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceRandomizedValidHitPart;                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMaxInitialPartVelocityOverrides;                // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableMaxInitialPartVelocityOverridesIfMidair;    // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInitialPartLinearVelocity;                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInitialPartAngularVelocity;                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopMotionParallelToImpulse;                       // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwitchToExplosionSpeed;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableImpulseIfNoInitialSupports;                 // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ZeroInitialVelocitiesFromHitPartToRoot;            // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideSwitchToFallTimeout;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EeBodyParts>                           OverrideHitParts;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ChanceOfPartOverride;                              // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPartImpulseOverride>           PartImpulseOverrides;                              // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EmphasizeHeadDistMult;                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmphasizeFirstOverridePartDistMult;                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClampAngleVertically;                              // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVerticalAngle;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalAngle;                                  // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClampAngleToFacingCone;                            // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxConeAngleFromFacing;                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleFromFacingRandomization;                      // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyAvoidAnglesToExplosionsAsWell;                // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvoidFrontAngle;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidBackAngle;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitude;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMultWhenFallen;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactOutMagRatio;                                 // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitudeLowerBody;                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitudeArms;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitudeHands;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactTime;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactOutTime;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactDecayRate;                                   // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImpactMaxNumDecayStages;                           // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImpactRelativeToPartMass;                          // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPartImpulseOverride>           PartImpactOverrides;                               // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          StayUprightTorqueOrientationUsesTracking;          // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StayUprightTorqueMagnitude;                        // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightLiftMagnitude;                          // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LiftEntireSpine;                                   // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StayUprightMinTimeLift;                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMaxTimeLift;                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMinTimeTorque;                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMaxTimeTorque;                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMinMagAngle;                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMaxMagAngle;                            // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightBailBodyAngle;                          // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EeBodyParts>                           StayUprightTorqueParts;                            // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          StayUprightOnlyOnAllFours;                         // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StayUprightOnlyOnAllFoursMaxBodyAngle;             // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainHunchAngle;                                    // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainPeakStartTime;                                 // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainPeakDuration;                                  // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainPeakFalloffTime;                               // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PainOnlyUseForIncludeParts;                        // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EeBodyParts>                           PainIncludeParts;                                  // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EeBodyParts>                           PainExcludeParts;                                  // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGravityAndAirResistanceControl        GravityAndAirResistanceControl;                    // 0x0158(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpulse) == 0x000008, "Wrong alignment on FImpulse");
static_assert(sizeof(FImpulse) == 0x000198, "Wrong size on FImpulse");
static_assert(offsetof(FImpulse, Enabled) == 0x000000, "Member 'FImpulse::Enabled' has a wrong offset!");
static_assert(offsetof(FImpulse, Impulse) == 0x000004, "Member 'FImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseArms) == 0x000008, "Member 'FImpulse::ImpulseArms' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseHands) == 0x00000C, "Member 'FImpulse::ImpulseHands' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseLegs) == 0x000010, "Member 'FImpulse::ImpulseLegs' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseMultWhenFallen) == 0x000014, "Member 'FImpulse::ImpulseMultWhenFallen' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseTime) == 0x000018, "Member 'FImpulse::ImpulseTime' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseRelativeToPartMass) == 0x00001C, "Member 'FImpulse::ImpulseRelativeToPartMass' has a wrong offset!");
static_assert(offsetof(FImpulse, AmountOfDecayPerStage) == 0x000020, "Member 'FImpulse::AmountOfDecayPerStage' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxNumDecayStages) == 0x000024, "Member 'FImpulse::MaxNumDecayStages' has a wrong offset!");
static_assert(offsetof(FImpulse, ForceRandomizedValidHitPart) == 0x000028, "Member 'FImpulse::ForceRandomizedValidHitPart' has a wrong offset!");
static_assert(offsetof(FImpulse, UseMaxInitialPartVelocityOverrides) == 0x000029, "Member 'FImpulse::UseMaxInitialPartVelocityOverrides' has a wrong offset!");
static_assert(offsetof(FImpulse, DisableMaxInitialPartVelocityOverridesIfMidair) == 0x00002A, "Member 'FImpulse::DisableMaxInitialPartVelocityOverridesIfMidair' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxInitialPartLinearVelocity) == 0x00002C, "Member 'FImpulse::MaxInitialPartLinearVelocity' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxInitialPartAngularVelocity) == 0x000030, "Member 'FImpulse::MaxInitialPartAngularVelocity' has a wrong offset!");
static_assert(offsetof(FImpulse, StopMotionParallelToImpulse) == 0x000034, "Member 'FImpulse::StopMotionParallelToImpulse' has a wrong offset!");
static_assert(offsetof(FImpulse, SwitchToExplosionSpeed) == 0x000038, "Member 'FImpulse::SwitchToExplosionSpeed' has a wrong offset!");
static_assert(offsetof(FImpulse, DisableImpulseIfNoInitialSupports) == 0x00003C, "Member 'FImpulse::DisableImpulseIfNoInitialSupports' has a wrong offset!");
static_assert(offsetof(FImpulse, ZeroInitialVelocitiesFromHitPartToRoot) == 0x00003D, "Member 'FImpulse::ZeroInitialVelocitiesFromHitPartToRoot' has a wrong offset!");
static_assert(offsetof(FImpulse, OverrideSwitchToFallTimeout) == 0x000040, "Member 'FImpulse::OverrideSwitchToFallTimeout' has a wrong offset!");
static_assert(offsetof(FImpulse, OverrideHitParts) == 0x000048, "Member 'FImpulse::OverrideHitParts' has a wrong offset!");
static_assert(offsetof(FImpulse, ChanceOfPartOverride) == 0x000058, "Member 'FImpulse::ChanceOfPartOverride' has a wrong offset!");
static_assert(offsetof(FImpulse, PartImpulseOverrides) == 0x000060, "Member 'FImpulse::PartImpulseOverrides' has a wrong offset!");
static_assert(offsetof(FImpulse, EmphasizeHeadDistMult) == 0x000070, "Member 'FImpulse::EmphasizeHeadDistMult' has a wrong offset!");
static_assert(offsetof(FImpulse, EmphasizeFirstOverridePartDistMult) == 0x000074, "Member 'FImpulse::EmphasizeFirstOverridePartDistMult' has a wrong offset!");
static_assert(offsetof(FImpulse, ClampAngleVertically) == 0x000078, "Member 'FImpulse::ClampAngleVertically' has a wrong offset!");
static_assert(offsetof(FImpulse, MinVerticalAngle) == 0x00007C, "Member 'FImpulse::MinVerticalAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxVerticalAngle) == 0x000080, "Member 'FImpulse::MaxVerticalAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, ClampAngleToFacingCone) == 0x000084, "Member 'FImpulse::ClampAngleToFacingCone' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxConeAngleFromFacing) == 0x000088, "Member 'FImpulse::MaxConeAngleFromFacing' has a wrong offset!");
static_assert(offsetof(FImpulse, AngleFromFacingRandomization) == 0x00008C, "Member 'FImpulse::AngleFromFacingRandomization' has a wrong offset!");
static_assert(offsetof(FImpulse, ApplyAvoidAnglesToExplosionsAsWell) == 0x000090, "Member 'FImpulse::ApplyAvoidAnglesToExplosionsAsWell' has a wrong offset!");
static_assert(offsetof(FImpulse, AvoidFrontAngle) == 0x000094, "Member 'FImpulse::AvoidFrontAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, AvoidBackAngle) == 0x000098, "Member 'FImpulse::AvoidBackAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitude) == 0x00009C, "Member 'FImpulse::ImpactMagnitude' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMultWhenFallen) == 0x0000A0, "Member 'FImpulse::ImpactMultWhenFallen' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactOutMagRatio) == 0x0000A4, "Member 'FImpulse::ImpactOutMagRatio' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitudeLowerBody) == 0x0000A8, "Member 'FImpulse::ImpactMagnitudeLowerBody' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitudeArms) == 0x0000AC, "Member 'FImpulse::ImpactMagnitudeArms' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitudeHands) == 0x0000B0, "Member 'FImpulse::ImpactMagnitudeHands' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactTime) == 0x0000B4, "Member 'FImpulse::ImpactTime' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactOutTime) == 0x0000B8, "Member 'FImpulse::ImpactOutTime' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactDecayRate) == 0x0000BC, "Member 'FImpulse::ImpactDecayRate' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMaxNumDecayStages) == 0x0000C0, "Member 'FImpulse::ImpactMaxNumDecayStages' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactRelativeToPartMass) == 0x0000C4, "Member 'FImpulse::ImpactRelativeToPartMass' has a wrong offset!");
static_assert(offsetof(FImpulse, PartImpactOverrides) == 0x0000C8, "Member 'FImpulse::PartImpactOverrides' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightTorqueOrientationUsesTracking) == 0x0000D8, "Member 'FImpulse::StayUprightTorqueOrientationUsesTracking' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightTorqueMagnitude) == 0x0000DC, "Member 'FImpulse::StayUprightTorqueMagnitude' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightLiftMagnitude) == 0x0000E0, "Member 'FImpulse::StayUprightLiftMagnitude' has a wrong offset!");
static_assert(offsetof(FImpulse, LiftEntireSpine) == 0x0000E4, "Member 'FImpulse::LiftEntireSpine' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMinTimeLift) == 0x0000E8, "Member 'FImpulse::StayUprightMinTimeLift' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMaxTimeLift) == 0x0000EC, "Member 'FImpulse::StayUprightMaxTimeLift' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMinTimeTorque) == 0x0000F0, "Member 'FImpulse::StayUprightMinTimeTorque' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMaxTimeTorque) == 0x0000F4, "Member 'FImpulse::StayUprightMaxTimeTorque' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMinMagAngle) == 0x0000F8, "Member 'FImpulse::StayUprightMinMagAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMaxMagAngle) == 0x0000FC, "Member 'FImpulse::StayUprightMaxMagAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightBailBodyAngle) == 0x000100, "Member 'FImpulse::StayUprightBailBodyAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightTorqueParts) == 0x000108, "Member 'FImpulse::StayUprightTorqueParts' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightOnlyOnAllFours) == 0x000118, "Member 'FImpulse::StayUprightOnlyOnAllFours' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightOnlyOnAllFoursMaxBodyAngle) == 0x00011C, "Member 'FImpulse::StayUprightOnlyOnAllFoursMaxBodyAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, PainHunchAngle) == 0x000120, "Member 'FImpulse::PainHunchAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, PainPeakStartTime) == 0x000124, "Member 'FImpulse::PainPeakStartTime' has a wrong offset!");
static_assert(offsetof(FImpulse, PainPeakDuration) == 0x000128, "Member 'FImpulse::PainPeakDuration' has a wrong offset!");
static_assert(offsetof(FImpulse, PainPeakFalloffTime) == 0x00012C, "Member 'FImpulse::PainPeakFalloffTime' has a wrong offset!");
static_assert(offsetof(FImpulse, PainOnlyUseForIncludeParts) == 0x000130, "Member 'FImpulse::PainOnlyUseForIncludeParts' has a wrong offset!");
static_assert(offsetof(FImpulse, PainIncludeParts) == 0x000138, "Member 'FImpulse::PainIncludeParts' has a wrong offset!");
static_assert(offsetof(FImpulse, PainExcludeParts) == 0x000148, "Member 'FImpulse::PainExcludeParts' has a wrong offset!");
static_assert(offsetof(FImpulse, GravityAndAirResistanceControl) == 0x000158, "Member 'FImpulse::GravityAndAirResistanceControl' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.DirectedBlendout
// 0x01B0 (0x01B0 - 0x0000)
struct FDirectedBlendout final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpulse                               StayUprightValues;                                 // 0x0008(0x0198)(Edit, NativeAccessSpecifierPublic)
	float                                         BlendOutTimeStartMin;                              // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstraintReturnLinVel;                            // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstraintReturnAngVel;                            // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectedBlendout) == 0x000008, "Wrong alignment on FDirectedBlendout");
static_assert(sizeof(FDirectedBlendout) == 0x0001B0, "Wrong size on FDirectedBlendout");
static_assert(offsetof(FDirectedBlendout, Enabled) == 0x000000, "Member 'FDirectedBlendout::Enabled' has a wrong offset!");
static_assert(offsetof(FDirectedBlendout, StayUprightValues) == 0x000008, "Member 'FDirectedBlendout::StayUprightValues' has a wrong offset!");
static_assert(offsetof(FDirectedBlendout, BlendOutTimeStartMin) == 0x0001A0, "Member 'FDirectedBlendout::BlendOutTimeStartMin' has a wrong offset!");
static_assert(offsetof(FDirectedBlendout, BlendOutDuration) == 0x0001A4, "Member 'FDirectedBlendout::BlendOutDuration' has a wrong offset!");
static_assert(offsetof(FDirectedBlendout, ConstraintReturnLinVel) == 0x0001A8, "Member 'FDirectedBlendout::ConstraintReturnLinVel' has a wrong offset!");
static_assert(offsetof(FDirectedBlendout, ConstraintReturnAngVel) == 0x0001AC, "Member 'FDirectedBlendout::ConstraintReturnAngVel' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.FallArmsLegsAndSpineControl
// 0x00D8 (0x00D8 - 0x0000)
struct FFallArmsLegsAndSpineControl final
{
public:
	float                                         RangeLimWindmill;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightWindmill;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindmillRampUpTime;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StiffnessWindmill;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindmillJointSpeed;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedWindmill;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistWindmill;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadWindmill;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffsetWindmill;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpOffsetWindmill;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindmillMaxLengthRatio;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsStartTime;                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsRampUpTime;                           // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsStiffness;                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsJointSpeed;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsFrontDistance;                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsBackDistance;                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsSideDistance;                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsDownDistance;                         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsKickSpeed;                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLegsJointLimitSqueezeMult;                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionTrackingStiffness;                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionSpineStiffness;                           // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionStartRampTime;                            // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRampDuration;                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionTotalAngleChange;                         // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoWrithe;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WritheTimeStiffnessPeak;                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheTimeStiffnessPeakHead;                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheTimeStiffnessZero;                           // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheSwitchToUndulateHeadTime;                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheLegRotspeed;                                 // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheLegRadiusRatioOfLegLength;                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheLegMidpointRatioOfLegLength;                 // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheLegFrontRatioOfLegLength;                    // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheLegWeight;                                   // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheLegStiffness;                                // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheLegIKSpeed;                                  // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheUndulateSpeed;                               // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheUndulateAmplitude;                           // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheUndulateHeadAmpMult;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheUndulateStepDiff;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheUndulateStiffness;                           // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheUndulatePriority;                            // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheUndulateJointSpeed;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheRaiseNeckStiffness;                          // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheRaiseNeckPriorityMax;                        // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheRaiseNeckSpeed;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheRaiseNeckMag;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheRaiseNeckRampOutTime;                        // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheOnSideAngleLimDef;                           // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheTimeoutIfNotYetStartedDef;                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WritheMaxSpeedDef;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WritheProgressTimeIfInvalid;                       // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFallArmsLegsAndSpineControl) == 0x000004, "Wrong alignment on FFallArmsLegsAndSpineControl");
static_assert(sizeof(FFallArmsLegsAndSpineControl) == 0x0000D8, "Wrong size on FFallArmsLegsAndSpineControl");
static_assert(offsetof(FFallArmsLegsAndSpineControl, RangeLimWindmill) == 0x000000, "Member 'FFallArmsLegsAndSpineControl::RangeLimWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WeightWindmill) == 0x000004, "Member 'FFallArmsLegsAndSpineControl::WeightWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WindmillRampUpTime) == 0x000008, "Member 'FFallArmsLegsAndSpineControl::WindmillRampUpTime' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, StiffnessWindmill) == 0x00000C, "Member 'FFallArmsLegsAndSpineControl::StiffnessWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WindmillJointSpeed) == 0x000010, "Member 'FFallArmsLegsAndSpineControl::WindmillJointSpeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, RotationSpeedWindmill) == 0x000014, "Member 'FFallArmsLegsAndSpineControl::RotationSpeedWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, DistWindmill) == 0x000018, "Member 'FFallArmsLegsAndSpineControl::DistWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, RadWindmill) == 0x00001C, "Member 'FFallArmsLegsAndSpineControl::RadWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ForwardOffsetWindmill) == 0x000020, "Member 'FFallArmsLegsAndSpineControl::ForwardOffsetWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, UpOffsetWindmill) == 0x000024, "Member 'FFallArmsLegsAndSpineControl::UpOffsetWindmill' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WindmillMaxLengthRatio) == 0x000028, "Member 'FFallArmsLegsAndSpineControl::WindmillMaxLengthRatio' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsStartTime) == 0x00002C, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsStartTime' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsRampUpTime) == 0x000030, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsRampUpTime' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsStiffness) == 0x000034, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsStiffness' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsJointSpeed) == 0x000038, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsJointSpeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsFrontDistance) == 0x00003C, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsFrontDistance' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsBackDistance) == 0x000040, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsBackDistance' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsSideDistance) == 0x000044, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsSideDistance' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsDownDistance) == 0x000048, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsDownDistance' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsKickSpeed) == 0x00004C, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsKickSpeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionLegsJointLimitSqueezeMult) == 0x000050, "Member 'FFallArmsLegsAndSpineControl::ExplosionLegsJointLimitSqueezeMult' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionTrackingStiffness) == 0x000054, "Member 'FFallArmsLegsAndSpineControl::ExplosionTrackingStiffness' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionSpineStiffness) == 0x000058, "Member 'FFallArmsLegsAndSpineControl::ExplosionSpineStiffness' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionStartRampTime) == 0x00005C, "Member 'FFallArmsLegsAndSpineControl::ExplosionStartRampTime' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionRampDuration) == 0x000060, "Member 'FFallArmsLegsAndSpineControl::ExplosionRampDuration' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, ExplosionTotalAngleChange) == 0x000064, "Member 'FFallArmsLegsAndSpineControl::ExplosionTotalAngleChange' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, DoWrithe) == 0x000068, "Member 'FFallArmsLegsAndSpineControl::DoWrithe' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheTimeStiffnessPeak) == 0x00006C, "Member 'FFallArmsLegsAndSpineControl::WritheTimeStiffnessPeak' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheTimeStiffnessPeakHead) == 0x000070, "Member 'FFallArmsLegsAndSpineControl::WritheTimeStiffnessPeakHead' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheTimeStiffnessZero) == 0x000074, "Member 'FFallArmsLegsAndSpineControl::WritheTimeStiffnessZero' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheSwitchToUndulateHeadTime) == 0x000078, "Member 'FFallArmsLegsAndSpineControl::WritheSwitchToUndulateHeadTime' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheLegRotspeed) == 0x00007C, "Member 'FFallArmsLegsAndSpineControl::WritheLegRotspeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheLegRadiusRatioOfLegLength) == 0x000080, "Member 'FFallArmsLegsAndSpineControl::WritheLegRadiusRatioOfLegLength' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheLegMidpointRatioOfLegLength) == 0x000084, "Member 'FFallArmsLegsAndSpineControl::WritheLegMidpointRatioOfLegLength' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheLegFrontRatioOfLegLength) == 0x000088, "Member 'FFallArmsLegsAndSpineControl::WritheLegFrontRatioOfLegLength' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheLegWeight) == 0x00008C, "Member 'FFallArmsLegsAndSpineControl::WritheLegWeight' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheLegStiffness) == 0x000090, "Member 'FFallArmsLegsAndSpineControl::WritheLegStiffness' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheLegIKSpeed) == 0x000094, "Member 'FFallArmsLegsAndSpineControl::WritheLegIKSpeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheUndulateSpeed) == 0x000098, "Member 'FFallArmsLegsAndSpineControl::WritheUndulateSpeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheUndulateAmplitude) == 0x00009C, "Member 'FFallArmsLegsAndSpineControl::WritheUndulateAmplitude' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheUndulateHeadAmpMult) == 0x0000A0, "Member 'FFallArmsLegsAndSpineControl::WritheUndulateHeadAmpMult' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheUndulateStepDiff) == 0x0000A4, "Member 'FFallArmsLegsAndSpineControl::WritheUndulateStepDiff' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheUndulateStiffness) == 0x0000A8, "Member 'FFallArmsLegsAndSpineControl::WritheUndulateStiffness' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheUndulatePriority) == 0x0000AC, "Member 'FFallArmsLegsAndSpineControl::WritheUndulatePriority' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheUndulateJointSpeed) == 0x0000B0, "Member 'FFallArmsLegsAndSpineControl::WritheUndulateJointSpeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheRaiseNeckStiffness) == 0x0000B4, "Member 'FFallArmsLegsAndSpineControl::WritheRaiseNeckStiffness' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheRaiseNeckPriorityMax) == 0x0000B8, "Member 'FFallArmsLegsAndSpineControl::WritheRaiseNeckPriorityMax' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheRaiseNeckSpeed) == 0x0000BC, "Member 'FFallArmsLegsAndSpineControl::WritheRaiseNeckSpeed' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheRaiseNeckMag) == 0x0000C0, "Member 'FFallArmsLegsAndSpineControl::WritheRaiseNeckMag' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheRaiseNeckRampOutTime) == 0x0000C4, "Member 'FFallArmsLegsAndSpineControl::WritheRaiseNeckRampOutTime' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheOnSideAngleLimDef) == 0x0000C8, "Member 'FFallArmsLegsAndSpineControl::WritheOnSideAngleLimDef' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheTimeoutIfNotYetStartedDef) == 0x0000CC, "Member 'FFallArmsLegsAndSpineControl::WritheTimeoutIfNotYetStartedDef' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheMaxSpeedDef) == 0x0000D0, "Member 'FFallArmsLegsAndSpineControl::WritheMaxSpeedDef' has a wrong offset!");
static_assert(offsetof(FFallArmsLegsAndSpineControl, WritheProgressTimeIfInvalid) == 0x0000D4, "Member 'FFallArmsLegsAndSpineControl::WritheProgressTimeIfInvalid' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.Explosion
// 0x0498 (0x0498 - 0x0000)
struct FExplosion final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBaseRagdollRegardless;                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseImpulseDataAsWell;                              // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipLinearVelocityControl;                         // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipBaseDataVelocityClamp;                         // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinLinearMagnitude;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearMagnitude;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearForceApplyTime;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosestDistanceToScaleMagnitude;                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarthestDistanceToScaleMagnitude;                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngleFromHorizon;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleFromHorizon;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidFrontAngle;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidBackAngle;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpulse                               DistanceScaledImpactData;                          // 0x0030(0x0198)(Edit, NativeAccessSpecifierPublic)
	float                                         LinearMagnitudeForContactExplosions;               // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleFromHorizonOverrideForContactExplosions;      // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationOppositeOfExplosionDirection;              // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationUseDesiredBodyVelocity;                    // 0x01D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationConstrainOtherRotVelocity;                 // 0x01D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D3[0x1];                                      // 0x01D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationSpeedForContactExplosion;                  // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationStartTime;                                 // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDuration;                                  // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FImpulse                               ContactImpactData;                                 // 0x01E0(0x0198)(Edit, NativeAccessSpecifierPublic)
	struct FGravityAndAirResistanceControl        GravityAndAirResistanceControl;                    // 0x0378(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseOverrideBodyControl;                            // 0x03B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFallArmsLegsAndSpineControl           OverrideBodyControl;                               // 0x03BC(0x00D8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExplosion) == 0x000008, "Wrong alignment on FExplosion");
static_assert(sizeof(FExplosion) == 0x000498, "Wrong size on FExplosion");
static_assert(offsetof(FExplosion, Enabled) == 0x000000, "Member 'FExplosion::Enabled' has a wrong offset!");
static_assert(offsetof(FExplosion, UseBaseRagdollRegardless) == 0x000001, "Member 'FExplosion::UseBaseRagdollRegardless' has a wrong offset!");
static_assert(offsetof(FExplosion, UseImpulseDataAsWell) == 0x000002, "Member 'FExplosion::UseImpulseDataAsWell' has a wrong offset!");
static_assert(offsetof(FExplosion, SkipLinearVelocityControl) == 0x000003, "Member 'FExplosion::SkipLinearVelocityControl' has a wrong offset!");
static_assert(offsetof(FExplosion, SkipBaseDataVelocityClamp) == 0x000004, "Member 'FExplosion::SkipBaseDataVelocityClamp' has a wrong offset!");
static_assert(offsetof(FExplosion, MinLinearMagnitude) == 0x000008, "Member 'FExplosion::MinLinearMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, MaxLinearMagnitude) == 0x00000C, "Member 'FExplosion::MaxLinearMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, LinearForceApplyTime) == 0x000010, "Member 'FExplosion::LinearForceApplyTime' has a wrong offset!");
static_assert(offsetof(FExplosion, ClosestDistanceToScaleMagnitude) == 0x000014, "Member 'FExplosion::ClosestDistanceToScaleMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, FarthestDistanceToScaleMagnitude) == 0x000018, "Member 'FExplosion::FarthestDistanceToScaleMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, MinAngleFromHorizon) == 0x00001C, "Member 'FExplosion::MinAngleFromHorizon' has a wrong offset!");
static_assert(offsetof(FExplosion, MaxAngleFromHorizon) == 0x000020, "Member 'FExplosion::MaxAngleFromHorizon' has a wrong offset!");
static_assert(offsetof(FExplosion, AvoidFrontAngle) == 0x000024, "Member 'FExplosion::AvoidFrontAngle' has a wrong offset!");
static_assert(offsetof(FExplosion, AvoidBackAngle) == 0x000028, "Member 'FExplosion::AvoidBackAngle' has a wrong offset!");
static_assert(offsetof(FExplosion, DistanceScaledImpactData) == 0x000030, "Member 'FExplosion::DistanceScaledImpactData' has a wrong offset!");
static_assert(offsetof(FExplosion, LinearMagnitudeForContactExplosions) == 0x0001C8, "Member 'FExplosion::LinearMagnitudeForContactExplosions' has a wrong offset!");
static_assert(offsetof(FExplosion, AngleFromHorizonOverrideForContactExplosions) == 0x0001CC, "Member 'FExplosion::AngleFromHorizonOverrideForContactExplosions' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationOppositeOfExplosionDirection) == 0x0001D0, "Member 'FExplosion::RotationOppositeOfExplosionDirection' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationUseDesiredBodyVelocity) == 0x0001D1, "Member 'FExplosion::RotationUseDesiredBodyVelocity' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationConstrainOtherRotVelocity) == 0x0001D2, "Member 'FExplosion::RotationConstrainOtherRotVelocity' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationSpeedForContactExplosion) == 0x0001D4, "Member 'FExplosion::RotationSpeedForContactExplosion' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationStartTime) == 0x0001D8, "Member 'FExplosion::RotationStartTime' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationDuration) == 0x0001DC, "Member 'FExplosion::RotationDuration' has a wrong offset!");
static_assert(offsetof(FExplosion, ContactImpactData) == 0x0001E0, "Member 'FExplosion::ContactImpactData' has a wrong offset!");
static_assert(offsetof(FExplosion, GravityAndAirResistanceControl) == 0x000378, "Member 'FExplosion::GravityAndAirResistanceControl' has a wrong offset!");
static_assert(offsetof(FExplosion, UseOverrideBodyControl) == 0x0003B8, "Member 'FExplosion::UseOverrideBodyControl' has a wrong offset!");
static_assert(offsetof(FExplosion, OverrideBodyControl) == 0x0003BC, "Member 'FExplosion::OverrideBodyControl' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.RagdollActivationTimeOverride
// 0x0008 (0x0008 - 0x0000)
struct FRagdollActivationTimeOverride final
{
public:
	EeEndBattleDamageSourceHitReactionType_BD     ReactionType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EeEndBattleDamageSourceProperty_BD            DamageSourceProperty;                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivationTime;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRagdollActivationTimeOverride) == 0x000004, "Wrong alignment on FRagdollActivationTimeOverride");
static_assert(sizeof(FRagdollActivationTimeOverride) == 0x000008, "Wrong size on FRagdollActivationTimeOverride");
static_assert(offsetof(FRagdollActivationTimeOverride, ReactionType) == 0x000000, "Member 'FRagdollActivationTimeOverride::ReactionType' has a wrong offset!");
static_assert(offsetof(FRagdollActivationTimeOverride, DamageSourceProperty) == 0x000001, "Member 'FRagdollActivationTimeOverride::DamageSourceProperty' has a wrong offset!");
static_assert(offsetof(FRagdollActivationTimeOverride, ActivationTime) == 0x000004, "Member 'FRagdollActivationTimeOverride::ActivationTime' has a wrong offset!");

}

